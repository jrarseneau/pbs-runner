# config.example.yaml

# pbs-runner — example configuration
# Copy to config.yaml and tailor to your environment.
# This example includes all options (many commented out) for reference.

# -------------------------
# PBS repositories (env injected per command; no wrapper needed)
# -------------------------
repositories:
  # Define each PBS repo once and reference by its alias in folders.
  my_repo:
    repository: "user@pbs@pbs.example.com:datastore1"   # exported as PBS_REPOSITORY
    password:   "supersecret"                   # exported as PBS_PASSWORD
    fingerprint: "aa:bb:cc:dd:ee:ff:..."        # exported as PBS_FINGERPRINT 

  # cloud:
  #   repository: "user@pbs@cloud-pbs.example.com:datastore"
  #   password:   "anothersecret"
  #   fingerprint: ""

# -------------------------
# Global defaults (overridable at section and folder levels)
# -------------------------
defaults:
  # ZFS snapshotting:
  snapshot: false                 # create ZFS snapshots and back up from snapshot paths
  split_subfolders: false         # split folder into immediate subfolders as individual items
  fallback_to_live: true          # if snapshotting fails/unavailable, back up live paths (warn)
  skip_hidden_subfolders: true    # ignore subfolders that start with '.' when splitting

  # Grouping of backups into PBS snapshots:
  # - bundle        : items sharing (repo, ns, backup-id) are bundled into one command
  # - per-app-id    : each item uses its own --backup-id (from backup_id_template)
  # - per-namespace : each item uses its own --ns (from namespace_template; namespaces must exist)
  backup_grouping: "bundle"
  backup_id_template: "{host}-{name}"     # tokens: {host}, {name}, {section}, {YYYY}, {MM}, {DD}
  namespace: ""                           # base namespace for items ('' => root)
  namespace_template: "{host}/{name}"       # used when backup_grouping=per-namespace

  # Union mode (bind-mounted unified snapshot view)
  # When snapshot=true AND split_subfolders=false:
  # - auto : build a temp union (bind) of parent snapshot + child dataset snapshots, then back up one pxar
  # - off  : disable union; parent snapshot will not include child dataset content (ZFS behavior)
  union_mode: "auto"
  union_mount_root: "/tmp"                # base directory where a unique mktemp-like dir will be created

  # Extra proxmox-backup-client options to append (be careful with quoting):
  # Example: ["--verbose"] or ["--rate", "50MB"]
  extra_args: []

  # Path to proxmox-backup-client binary
  pbc_binary: "/usr/local/bin/proxmox-backup-client"

  # Logging (console + rotating file)
  log:
    file: "/var/log/pbs-runner.log"                # consider an absolute path (e.g., /var/log/pbs_runner/pbs_runner.log)
    level: "INFO"
    rotate_max_bytes: 10485760            # 10 MiB
    rotate_backups: 5

# -------------------------
# Notifications (optional)
# -------------------------
notifications:
  healthcheck_url: ""                     # Healthchecks.io endpoint; pings /start, /fail, and success baseline
  discord_webhook: ""                     # Discord webhook URL
  discord_notify_on: ["failure", "fallback"]  # any of: start, success, failure, finish, fallback
  discord_prefix: "[pbs-runner]"          # prefix for Discord messages

# -------------------------
# Section: host
# -------------------------
host:
  # Backup group identity for this section (unless overridden by per-app-id mode)
  backup_id: "my_host"
  backup_type: "host"

  # Section-level overrides (inherit from defaults otherwise)
  snapshot: true
  split_subfolders: false
  fallback_to_live: true
  # namespace: ""                         # section-level namespace ('' => root)
  # backup_grouping: "bundle"             # override grouping here if desired
  # union_mode: "auto"                    # override per section
  # union_mount_root: "/tmp"              # override per section

  folders:
    # 1) Simple folder — no snapshot
    - path: "/boot"
      snapshot: false
      split_subfolders: false
      label: "boot"
      repositories: ["my_repo"]

    # 2) Appdata — single pxar using union mode (snapshot=true, split=false)
    - path: "/mnt/cache/appdata"
      snapshot: true
      split_subfolders: false             # union mode kicks in (since snapshot=true)
      # union_mode: "auto"                # optional override per folder
      # union_mount_root: "/tmp"          # optional override per folder
      backup_grouping: "bundle"           # one pxar, grouped with other items if same (repo, ns, bid)
      repositories: ["my_repo"]

    # 3) Appdata — per-app retention using split + per-app-id
    # - Each immediate subfolder becomes its own item and its own PBS group
    # - Good when you want separate retention for each app
    # - Note: union mode does NOT apply when splitting.
    # - Example is commented out; uncomment to use.
    # - path: "/mnt/nvme/appdata"
    #   snapshot: true
    #   split_subfolders: true
    #   backup_grouping: "per-app-id"
    #   backup_id_template: "{host}-{name}"    # e.g., my_host-plex, my_host-sonarr
    #   # label_prefix: "appdata"               # optional cosmetic prefix for pxar labels
    #   repositories: ["my_host"]

# -------------------------
# Section: vm
# -------------------------
vm:
  # VM backups use libvirt auto-discovery to find VMs
  # Each VM is backed up as a separate PBS backup-id using the VM name
  backup_type: "vm"                   # REQUIRED: must be "vm" for VM backups

  # Section-level defaults for all VMs
  snapshot: true                      # Create ZFS snapshots of VM disks before backup
  fallback_to_live: true              # If snapshot fails, backup live disks (with warning)
  check_vm_state: true                # Check if VM is running via virsh
  warn_if_running: true               # Warn if VM is running but continue backup

  # libvirt-specific settings
  libvirt:
    virsh_uri: "qemu:///system"       # libvirt connection URI
    config_path: /etc/libvirt/qemu    # Where VM XML configs are stored

  # Auto-discovery of VMs from libvirt
  auto_discover:
    enabled: true                     # Enable auto-discovery
    config_path: /etc/libvirt/qemu    # Override libvirt config path if needed
    repositories:
      - my_repo                       # PBS repository to backup to

    # Optional: namespace for VM backups (supports template variables)
    # Examples:
    #   namespace: "vms"              # All VMs in /vms namespace
    #   namespace: "{host}/vms"       # /hostname/vms namespace
    #   namespace: "vms/{vm}"         # /vms/vm-name namespace
    # namespace: "vms"

    # Optional: filters for VM discovery
    # exclude_vms:                    # Exclude VMs matching these patterns (glob)
    #   - "test-*"                    # Exclude all VMs starting with "test-"
    #   - "temp-vm"                   # Exclude specific VM
    # include_only:                   # Only include VMs matching these patterns
    #   - "prod-*"                    # Only backup VMs starting with "prod-"

  # -------------------------
  # Unraid-specific example (commented out)
  # -------------------------
  # For Unraid systems, the config is identical since Unraid uses libvirt
  # Unraid stores VM configs in /etc/libvirt/qemu by default
  # Unraid stores VM disks in /mnt/user/domains/<vm-name>/ by default
  #
  # Example for Unraid:
  # auto_discover:
  #   enabled: true
  #   config_path: /etc/libvirt/qemu  # Default Unraid location
  #   repositories:
  #     - my_repo
  #   namespace: "{host}/vms"
  #   exclude_vms:
  #     - "Windows*"                  # Example: skip Windows VMs

  # -------------------------
  # How VM backups work:
  # -------------------------
  # 1. Scans /etc/libvirt/qemu for *.xml files
  # 2. Parses each XML to extract VM name and disk paths
  # 3. For each disk:
  #    - If file (qcow2/raw): finds parent ZFS dataset and snapshots it
  #    - If zvol (/dev/zvol/...): snapshots the zvol directly
  # 4. Backs up each disk from snapshot + VM config XML
  # 5. Uses VM name as --backup-id (not numeric VMID)
  # 6. Cleans up snapshots after backup completes
  #
  # Example PBS backup structure:
  #   vm/<backup-id>/<timestamp>/
  #     vdisk1.pxar       (VM disk 1)
  #     vdisk2.pxar       (VM disk 2)
  #     vm-config.pxar    (VM XML config)

  # -------------------------
  # Manual VM configuration (future feature - not yet implemented)
  # -------------------------
  # manual_vms:
  #   - name: special-vm
  #     vm_name: "special-vm"           # Name in virsh
  #     path: /custom/vm/location
  #     config_file: /custom/vm.xml
  #     repositories:
  #       - my_repo

# -------------------------
# Section: ct (reserved for future)
# -------------------------
ct:
  backup_id: "my_host-ct"
  backup_type: "ct"
  # folders: []
